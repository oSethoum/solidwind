export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  firstName: Scalars['String'];
  friendIDs?: InputMaybe<Array<Scalars['ID']>>;
  lastName: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  createUser: User;
  updateUser: User;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationUpdateUserArgs = {
  id: Scalars['ID'];
  input: UpdateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Query = {
  __typename?: 'Query';
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  users: UserConnection;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UserOrder>;
  where?: InputMaybe<UserWhereInput>;
};

export type Subscription = {
  __typename?: 'Subscription';
  userCreated: User;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addFriendIDs?: InputMaybe<Array<Scalars['ID']>>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  removeFriendIDs?: InputMaybe<Array<Scalars['ID']>>;
};

export type User = Node & {
  __typename?: 'User';
  firstName: Scalars['String'];
  friends?: Maybe<Array<User>>;
  id: Scalars['ID'];
  lastName: Scalars['String'];
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  FirstName = 'FIRST_NAME',
  LastName = 'LAST_NAME'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** first_name field predicates */
  firstName?: InputMaybe<Scalars['String']>;
  firstNameContains?: InputMaybe<Scalars['String']>;
  firstNameContainsFold?: InputMaybe<Scalars['String']>;
  firstNameEqualFold?: InputMaybe<Scalars['String']>;
  firstNameGT?: InputMaybe<Scalars['String']>;
  firstNameGTE?: InputMaybe<Scalars['String']>;
  firstNameHasPrefix?: InputMaybe<Scalars['String']>;
  firstNameHasSuffix?: InputMaybe<Scalars['String']>;
  firstNameIn?: InputMaybe<Array<Scalars['String']>>;
  firstNameLT?: InputMaybe<Scalars['String']>;
  firstNameLTE?: InputMaybe<Scalars['String']>;
  firstNameNEQ?: InputMaybe<Scalars['String']>;
  firstNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** friends edge predicates */
  hasFriends?: InputMaybe<Scalars['Boolean']>;
  hasFriendsWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** last_name field predicates */
  lastName?: InputMaybe<Scalars['String']>;
  lastNameContains?: InputMaybe<Scalars['String']>;
  lastNameContainsFold?: InputMaybe<Scalars['String']>;
  lastNameEqualFold?: InputMaybe<Scalars['String']>;
  lastNameGT?: InputMaybe<Scalars['String']>;
  lastNameGTE?: InputMaybe<Scalars['String']>;
  lastNameHasPrefix?: InputMaybe<Scalars['String']>;
  lastNameHasSuffix?: InputMaybe<Scalars['String']>;
  lastNameIn?: InputMaybe<Array<Scalars['String']>>;
  lastNameLT?: InputMaybe<Scalars['String']>;
  lastNameLTE?: InputMaybe<Scalars['String']>;
  lastNameNEQ?: InputMaybe<Scalars['String']>;
  lastNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
};

export type UsersQueryVariables = Exact<{ [key: string]: never; }>;


export type UsersQuery = { __typename?: 'Query', users: { __typename?: 'UserConnection', edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, firstName: string, lastName: string } | null } | null> | null } };
